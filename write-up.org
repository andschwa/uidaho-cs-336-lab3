#+TITLE: 2013-FA-CS-336-LA-03-AndyS-SheaN
#+AUTHOR: Andrew Schwartzmeyer, Shea Newt
#+OPTIONS: toc:nil num:nil

| Year and Semester: | 2013 FALL                                   |
| Course Number:     | CS-336                                      |
| Course Title:      | Intro. to Information Assurance             |
| Work Number:       | LA-03                                       |
| Work Name:         | SQL Injection Attack Lab - Using Collabtive |
| Work Version:      | Version 1                                   |
| Long Date:         | Tuesday, 29 October 2013                    |
| Author Name:       | Andrew Schwartzmeyer, Shea Newt             |

* Abstract

* Problem and Background

* Problem Detail

* Tasks

** Turn off PHP Magic Quote Countermeasure

Prior to version 5.3.0, PHP enabled a countermeasure to SQL injection
attacks called "Magic Quote". To disable this, we simply edit the PHP
configuration file =/etc/php5/apache2/php.ini= and change the line
=magic quotes gpc = On= to =magic quotes gpc = Off=; finally, to make
these changes live, we execute the command =sudo service apache2
restart=. (Du 3)

** Lab Task 1: Exploiting the login prompt

The Collabtive web app on our virtual machine implements its user
authentication using the file
=/var/www/SQL/Collabtive/include/class.user.php=, which executes a SQL
query using the specified user and password parameters to determine if
a record exists which matches the pair of inputs. If so, it
authenticates the user. Unfortunately, the function looks like this:

#+BEGIN_SRC php
      function login($user, $pass)
      {
          if (!$user)
          {
              return false;
          }
  
  //modified for SQL Lab
          //$user = mysql_real_escape_string($user);
          //$pass = mysql_real_escape_string($pass);
          $pass = sha1($pass);
  
          $sel1 = mysql_query("SELECT ID,name,locale,lastlogin,gender FROM user WHERE (name =  '$user' OR email = '$user') AND pass = '$pass'");
          $chk = mysql_fetch_array($sel1);
          if ($chk["ID"] != "")
          {
              // New user session object and cookie creation code
              // removed for brevity
              return true;
          }
          else
          {
              return false;
          }
      }
#+END_SRC

Note specifically that the authors of the lab disabled the input
sanitization of the variables =$user= and =$pass= by commenting out
the exeuction of =mysql_real_escape_string()= on them. This leaves us
with the following SQL query executed by the PHP script, where both
=$user= and =$pass= are susceptible to an injection attack:

#+BEGIN_SRC sql
  SELECT ID,name,locale,lastlogin,gender FROM user WHERE (name = '$user'
  OR email = '$user') AND pass = '$pass'"
#+END_SRC

*** Task 1.1: Can you log into another person’s account without knowing the correct password?

We sure can! The key is being able to inject whatever SQL code we want
into the =$user= parameter, which is ahead of the =AND= conditional
password check in the =WHERE= clause. Hence, entering =​admin'); # '​=
into the user field bypasses the password check and logs us in. This
is because we complete the =name= predicate with the user =admin=
followed by a =​'​= followed by a =)=, which matches the =​'​= and =(=
before them in the query, then add a =;= to complete the query,
followed by a =#=, which comments out the rest of the query in the
original statement from the PHP code, and finally followed with a =​'​=
to match the trailing one surrounding our user input. We can enter
anything (or nothing) for the password, and be logged in as the
=admin= user, because the SQL code that was supposed to check the
password was disabled by our attack.

*** Task 1.2: Can you find a way to modify the database (still using the above SQL query?)

No, we were not able to modify the database through this particular
query. We tried injecting variations of =​admin'); UPDATE user SET
pass=​'pass' WHERE name=​'admin'; # '​=, where we added an =UPDATE= or
=DELETE FROM= query after the first, completed with a =;=, and still
followed by a "#", thus splitting the original query into two separate
queries. However, the MySQL database in particular does not allow
query stacking in the =mysql_query()= function. When we attempt to
execute two queries sequentially in the same =mysql_query()= function
call, MySQL itself causes the call, and therefore our attack, to
fail. Note that this is not necessarily true of other PHP database
extensions, which may or may not permit such query stacking. Since the
vulnerable query begins with a =SELECT= statement, and the attack is
only injectable further down in the query's string, MySQL's defense
mechanism limits us to only exploiting the =SELECT= query.

** Lab Task 2: SQL Injection on =UPDATE= Statements

The Collabtive web app also has a SQL injection vulnerability
elsewhere in the =/var/www/SQL/Collabtive/include/class.user.php=
file. On the "My Account" page, there is an "Edit" link that presents
the user with a form for editting their profile's information. This
form calls the following function:

#+BEGIN_SRC php
   function edit($id, $name, $realname, $email, $tel1, $tel2, $company, $zip, $gender, $url, $address1, $address2, $state, $country, $tags, $locale, $avatar = "", $rate = 0.0)
   {
        $name = mysql_real_escape_string($name);
        $realname = mysql_real_escape_string($realname);

//modified for SQL Lab
		//$company = mysql_real_escape_string($company);
        $email = mysql_real_escape_string($email);

// further escaped parameters removed for brevity...

        $rate = (float) $rate;
        $id = (int) $id;

        if ($avatar != "")
        {
// same query as below plus setting of avatar; removed for brevity...
        }
        else
        {
            $upd = mysql_query("UPDATE user SET name='$name',email='$email', tel1='$tel1', tel2='$tel2', company='$company',zip='$zip',gender='$gender',url='$url',adress='$address1',adress2='$address2',state='$state',country='$country',tags='$tags',locale='$locale',rate='$rate' WHERE ID = $id");
        }
        if ($upd)
        {
            $this->mylog->add($name, 'user', 2, 0);
            return true;
        }
        else
        {
            return false;
        }
    }
#+END_SRC

Here we note several things. First, the variable =$company=, which had
previously been escaped, has been modified by this lab's authors so
that it is susceptible to an injection attack, as it is no longer
escaped. Second, because of the previously mentioned MySQL defense
against query stacking, instead of using the statement =​SELECT ID
WHERE name=​'ted'​= as a subquery to return the ID of the user "ted" in
the attack itself (so that we can =UPDATE= the table row corresponding
exactly to his account), we had to manually experiment to find that
his ID is 4. Third, since passwords should never be stored as
plaintext, we had to further inspect the source code of the web
application to determine that it is using an unsalted SHA1 hash of the
password to represent it somewhat securely in the database. Thus, to
set the password to 'pass', since we could not call the PHP =sha1()=
function within the query, we had to manually hash the string 'pass',
to obtain the SHA1 hash of '9d4e1e23bd5b727046a9e3b4b7db57bd8d6ee684'.

Combining this information with that learned from our previous attack
(such as matching quotes where needed, and commenting out parts of a
query we wish to overwrite), we were able to develop a successful
attack, with these steps:

1. Log in as a user other than ted, since we want to change his
   password without his permission
2. Navigate to "My account" and click "Edit" to bring up the
   vulnerable form
3. Replace the user's name in the form with 'ted' (so that the attack retains his name in the database)
4. Type the following query into the vulnerable "company" field: =​', `pass` = '9d4e1e23bd5b727046a9e3b4b7db57bd8d6ee684' WHERE ID = 4 # '​=
5. Log out of the current user
6. Enjoy successfully logging into ted's account with the password
   'pass'

** Lab Task 3: Countermeasures
*** Magic Quotes

Re-enabling magic quotes by setting it to "On" in the file
=/etc/php5/apache2/php.ini= (in the same manner that we originally
used to turn it off) successfully prevents our SQL injection attacks:
we were unable to replicate the login prompt exploit, nor the edit
user form exploit. This is because it "magically" (read:
automatically) escapes any single quote ('), double quote ("),
backslash (\), or null characters found in an input string. Although
an effective countermeasure against our attacks, it has its
drawbacks. Most notably, since magic quotes may or may not be enabled
on any particular server, developers of PHP applications must include
a check of this setting, and incorporate logic to handle both cases,
lest their application not be portable to different
environments. Addtionally, magic quotes introduces performance
penalities by escaping every input string (not just those used for
user input), and can cause programming headaches when some data is not
supposed to be escaped, but is regardless.

*** =mysql_real_escape_string()=

As noted above, the SQL injection attacks were made viable
specifically beacuse of alterations made to the code by the lab's
authors. Below we present the fixed code that properly uses
=mysql_real_escape_string()= on all user inputs. Both these functions
come from =/var/www/SQL/Collabtive/include/class.user.php=.

The =mysql_real_escape_string()= function will escape these
characters, ~\x00, \n, \r, \, ', " and \x1a~, by prepending them with
a backslash (\) in the string it returns. By including code similar to
=$input = mysql_real_escape_string($input)= for all variables that
hold user input, such input will be properly escaped and, when passed
into a SQL query, not cause said query to be susceptible to the
attacks outlined in this lab. However, this function was deprecated as
of PHP version 5.5.0, and should be replaced with prepared statements.

#+BEGIN_SRC php
      function login($user, $pass)
      {
          if (!$user)
          {
              return false;
          }
  
  // modification fixed
          $user = mysql_real_escape_string($user);
          $pass = mysql_real_escape_string($pass);
          $pass = sha1($pass);
  
          $sel1 = mysql_query("SELECT ID,name,locale,lastlogin,gender FROM user WHERE (name =  '$user' OR email = '$user') AND pass = '$pass'");
          $chk = mysql_fetch_array($sel1);
          if ($chk["ID"] != "")
          {
              // New user session object and cookie creation code
              // removed for brevity
              return true;
          }
          else
          {
              return false;
          }
      }
#+END_SRC

#+BEGIN_SRC php
   function edit($id, $name, $realname, $email, $tel1, $tel2, $company, $zip, $gender, $url, $address1, $address2, $state, $country, $tags, $locale, $avatar = "", $rate = 0.0)
   {
        $name = mysql_real_escape_string($name);
        $realname = mysql_real_escape_string($realname);

// modification fixed
        $company = mysql_real_escape_string($company);
        $email = mysql_real_escape_string($email);

// further escaped parameters removed for brevity...

        $rate = (float) $rate;
        $id = (int) $id;

        if ($avatar != "")
        {
// same query as below plus setting of avatar; removed for brevity...
        }
        else
        {
            $upd = mysql_query("UPDATE user SET name='$name',email='$email', tel1='$tel1', tel2='$tel2', company='$company',zip='$zip',gender='$gender',url='$url',adress='$address1',adress2='$address2',state='$state',country='$country',tags='$tags',locale='$locale',rate='$rate' WHERE ID = $id");
        }
        if ($upd)
        {
            $this->mylog->add($name, 'user', 2, 0);
            return true;
        }
        else
        {
            return false;
        }
    }
#+END_SRC

#+BEGIN_SRC php
      function login($user, $pass)
      {
          if (!$user)
          {
              return false;
          }
  
  // modification fixed
          $user = mysql_real_escape_string($user);
          $pass = mysql_real_escape_string($pass);
          $pass = sha1($pass);
  
          $sel1 = mysql_query("SELECT ID,name,locale,lastlogin,gender FROM user WHERE (name =  '$user' OR email = '$user') AND pass = '$pass'");
          $chk = mysql_fetch_array($sel1);
          if ($chk["ID"] != "")
          {
              // New user session object and cookie creation code
              // removed for brevity
              return true;
          }
          else
          {
              return false;
          }
      }
#+END_SRC

#+BEGIN_SRC php
   function edit($id, $name, $realname, $email, $tel1, $tel2, $company, $zip, $gender, $url, $address1, $address2, $state, $country, $tags, $locale, $avatar = "", $rate = 0.0)
   {
        $name = mysql_real_escape_string($name);
        $realname = mysql_real_escape_string($realname);

// modification fixed
        $company = mysql_real_escape_string($company);
        $email = mysql_real_escape_string($email);

// further escaped parameters removed for brevity...

        $rate = (float) $rate;
        $id = (int) $id;

        if ($avatar != "")
        {
// same query as below plus setting of avatar; removed for brevity...
        }
        else
        {
            $upd = mysql_query("UPDATE user SET name='$name',email='$email', tel1='$tel1', tel2='$tel2', company='$company',zip='$zip',gender='$gender',url='$url',adress='$address1',adress2='$address2',state='$state',country='$country',tags='$tags',locale='$locale',rate='$rate' WHERE ID = $id");
        }
        if ($upd)
        {
            $this->mylog->add($name, 'user', 2, 0);
            return true;
        }
        else
        {
            return false;
        }
    }
#+END_SRC

* Answers

* Code

* References

Du, Wenliang. 2006-2013. "SQL Injection Attack Lab - Using
Collabtive". http://www.cis.syr.edu/~wedu/seed/Labs/Web/SQL_Injection_Collabtive/
